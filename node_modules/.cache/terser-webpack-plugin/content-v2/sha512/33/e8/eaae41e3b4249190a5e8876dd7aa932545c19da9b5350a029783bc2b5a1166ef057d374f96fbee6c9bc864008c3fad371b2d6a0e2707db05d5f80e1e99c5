{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{205:function(a,t,e){\"use strict\";e.r(t);var n=e(0),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[e(\"h3\",{attrs:{id:\"_10、layer开关switch\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10、layer开关switch\"}},[a._v(\"#\")]),a._v(\" 10、layer开关switch\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"有种选择是否条件的表单内容，本来做成下拉，但后面说不好看换成开关，刚好项目里的layer插件的api里有开关，就不去找其他了，具体代码：\")])]),a._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[a._v(\"<input class='standard_network' value='0' lay-filter='networkswitch' type='checkbox' name=\\\"standard_network\\\" lay-skin=\\\"switch\\\" lay-text=\\\"是|否\\\">\\n\")])])]),e(\"ul\",[e(\"li\",[a._v(\"由于switch在插件里是checkbox类型，与uniform插件冲突了，于是就在页面完成时append进去，再调用form.render渲染\")]),a._v(\" \"),e(\"li\",[a._v(\"但这个开关的难点是，input的开关的value只有一个，改变开关状态的值不变，而且官方没有给出如何用js控制修改开关的方法，找了很久终于找到解决方案：首先是开关切换时要修改值，需要在lay.use里监听开关的改变：\")])]),a._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[a._v(\"form.on('switch(networkswitch)', function(data){\\n    if(data.elem.checked){\\n        $(\\\".standard_network\\\").val('1');\\n    }else{\\n        $(\\\".standard_network\\\").val('0');\\n    }\\n});  \\n\")])])]),e(\"ul\",[e(\"li\",[a._v(\"其次是手动控制开关，这里要注意改变了开关的同时也要修改value:\")])]),a._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[a._v('$(\"input[name=\\'standard_network\\']\").prop(\"checked\",false);\\n$(\"input[name=\\'standard_network\\']\").val(\"0\");\\nlayui.form.render(\"checkbox\");\\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}